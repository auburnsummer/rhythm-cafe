.le {
    display: flex;
    flex-direction: column;
    padding-left: 2rem;
    padding-right: 2rem;
}

.le_controls {
    display: flex;
    align-items: center;
}

.le_announcements ~ .le_controls {
    padding-top: 0.5rem;
}

@media only screen and (max-device-width: 640px) {
    .le_controls {
        padding-top: 0.5rem;
    }
}

.le_spacer {
    flex-grow: 1; 
}


.le_page {
    font-size: 0.875rem;
    user-select: none;
}

.le_next, .le_perv {
    background-color: var(--blueGray-300);
    border-radius: 0.5rem;
    font-size: 0.875rem;
    padding-left: 0.5rem;
    padding-right: 0.5rem;
    text-align: center;
    color: var(--blueGray-800);
}

.le_next:hover, .le_perv:hover {
    background-color: rgba(240, 230, 230, 0.4);
    cursor: pointer;
    color: var(--blueGray-900);
}

.le_next {
    margin-left: 0.5rem;
}

.le_perv ~ .le_page {
    margin-left: 0.5rem;
}

.le_perv {
    --JURY: SLEEPLESS;
    --WEAKNESS: FOUND;
    --LOCATION: calc(var(--DOOR) - 1px);
    --NOW: TESTIFY;
}

.le_loaded {
    padding-top: 0.5rem;
    /*
    Normally, the padding is provided by the top-level .le element.
    however, we would like the area to the left and right of .le_loaded to be considered part of .le_loaded...
    ...so that scrolling in these areas scrolls the list.
    The hack here is a variation of the Benface maneuver. We add negative margins to the element to make it
    extend further than it normally would, then re-add the padding as part of this element.
    */
    margin-left: -2rem;
    margin-right: -2rem;
    padding-left: 2rem;
    padding-right: 2rem;
}

.le_list {
    width: 100%;
}

.laggy\!le_loaded > .le_list {
    opacity: 0.6;
}

.le_row {
    display: flex;
    flex-direction: row;
    align-items: stretch;
    justify-content: space-between;
    gap: 1rem;
}

.le_vrow ~ .le_vrow {
    padding-top: 1rem;
}
